research ideas for NemexA and NemexF

- 	implement MassJoin and PassJoin

- 	post filtering of "wrong" substrings, i.e., matched substrings that are in the wrong context, e.g.,
	"present" -> "ent" matches because it is a dictionary entry
	
-	ranking of candidates
	- according to Faerie paper page 536, advantage of binary pruning
		- the best similar pairs are those which share as many tokens as possible
	  	- group all candidates based on the same number of tokens
	  	- consider a group G_g with g tokens
	  	- let T_g be a threshold computed on basis of |e| and g
	  		 -> How exactly is this computed ?
	  	- then we prune all elements in group G_g, if |P_e[pi, ..., pj]| < T_g
	- check work done in un-supervised morphology
	
APPLICATIONS for NemexF:

-	finding similar questions

-	ngram-based morphology

-	OMQ data:
	- teste nemexf mit den daten von public omq
	- fragen als index und kategorien als value
	- neue fragen matchen
	- evtl. auch antworten als index
	
- MAKE NemexA and NemexF cluster based and parallel processing based
	- how to create distributed dictionaries and join them ?